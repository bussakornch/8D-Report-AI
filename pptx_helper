# pptx_helper.py

import json5
import pptx
from dotenv import load_dotenv
from pptx.enum.shapes import MSO_AUTO_SHAPE_TYPE
from pptx.shapes.placeholder import PicturePlaceholder, SlidePlaceholder
from pptx.util import Inches
import os
import random
import re
import logging
from typing import List, Tuple, Optional
import pathlib
from io import BytesIO # เพิ่มการ import BytesIO

import sys
sys.path.append('..')
sys.path.append('../../..') # อาจจะต้องปรับ path ให้ถูกต้องตามโครงสร้าง project ของคุณ


from global_config import GlobalConfig # ต้องแน่ใจว่า path ถูกต้อง

# ต้องแน่ใจว่า import helpers ถูกต้อง
# ตัวอย่าง:
import helpers.icons_embeddings as ice
import helpers.image_search as ims


load_dotenv()

# English Metric Unit (used by PowerPoint) to inches
EMU_TO_INCH_SCALING_FACTOR = 1.0 / 914400
INCHES_3 = pptx.util.Inches(3)
INCHES_2 = pptx.util.Inches(2)
INCHES_1_5 = pptx.util.Inches(1.5)
INCHES_1 = pptx.util.Inches(1)
INCHES_0_8 = pptx.util.Inches(0.8)
INCHES_0_9 = pptx.util.Inches(0.9)
INCHES_0_5 = pptx.util.Inches(0.5)
INCHES_0_4 = pptx.util.Inches(0.4)
INCHES_0_3 = pptx.util.Inches(0.3)
INCHES_0_2 = pptx.util.Inches(0.2)

STEP_BY_STEP_PROCESS_MARKER = '>> '
ICON_BEGINNING_MARKER = '[['
ICON_END_MARKER = ']]'

ICON_SIZE = INCHES_0_8
ICON_BG_SIZE = INCHES_1

IMAGE_DISPLAY_PROBABILITY = 1 / 3.0
FOREGROUND_IMAGE_PROBABILITY = 0.8

SLIDE_NUMBER_REGEX = re.compile(r"^slide[ ]+\d+:", re.IGNORECASE)
ICONS_REGEX = re.compile(r"\[\[(.*?)\]\]\s*(.*)")

ICON_COLORS = [
    pptx.dml.color.RGBColor.from_string('800000'),  # Maroon
    pptx.dml.color.RGBColor.from_string('6A5ACD'),  # SlateBlue
    pptx.dml.color.RGBColor.from_string('556B2F'),  # DarkOliveGreen
    pptx.dml.color.RGBColor.from_string('2F4F4F'),  # DarkSlateGray
    pptx.dml.color.RGBColor.from_string('4682B4'),  # SteelBlue
    pptx.dml.color.RGBColor.from_string('5F9EA0'),  # CadetBlue
]


logger = logging.getLogger(__name__)
logging.getLogger('PIL.PngImagePlugin').setLevel(logging.ERROR)


def remove_slide_number_from_heading(header: str) -> str:
    """
    Remove the slide number from a given slide header.

    :param header: The header of a slide.
    :return: The header without slide number.
    """

    if SLIDE_NUMBER_REGEX.match(header):
        idx = header.find(':')
        header = header[idx + 1:]

    return header


def generate_powerpoint_presentation(
        parsed_data: dict,
        slides_template: str,
        output_file_path: pathlib.Path
) -> List:
    """
    Create and save a PowerPoint presentation file containing the content in JSON format.

    :param parsed_data: The presentation content as parsed JSON data.
    :param slides_template: The PPTX template to use.
    :param output_file_path: The path of the PPTX file to save as.
    :return: A list of presentation title and slides headers.
    """

    presentation = pptx.Presentation(GlobalConfig.PPTX_TEMPLATE_FILES[slides_template]['file'])
    slide_width_inch, slide_height_inch = _get_slide_width_height_inches(presentation)

    # The title slide
    title_slide_layout = presentation.slide_layouts[0]
    slide = presentation.slides.add_slide(title_slide_layout)
    title = slide.shapes.title
    subtitle = slide.placeholders[1]
    title.text = parsed_data['title']
    logger.info(
        'PPT title: %s | #slides: %d | template: %s',
        title.text, len(parsed_data.get('slides', [])), # แก้ไขตรงนี้ให้รองรับกรณีที่ไม่มี 'slides'
        GlobalConfig.PPTX_TEMPLATE_FILES[slides_template]['file']
    )
    subtitle.text = 'Prepared by:Phanthiwa S.'
    all_headers = [title.text, ]

    # Add content in a loop
    for a_slide in parsed_data.get('slides', []): # แก้ไขตรงนี้ให้รองรับกรณีที่ไม่มี 'slides'
        try:
            # ตรวจสอบว่า slide_json มี 'type' เป็น '8d_report_table' หรือไม่
            if a_slide.get('type') == '8d_report_table':
                is_processing_done = _handle_8d_report_table(
                    presentation=presentation,
                    slide_json=a_slide,
                    slide_width_inch=slide_width_inch,
                    slide_height_inch=slide_height_inch
                )
            else:
                is_processing_done = _handle_icons_ideas(
                    presentation=presentation,
                    slide_json=a_slide,
                    slide_width_inch=slide_width_inch,
                    slide_height_inch=slide_height_inch
                )

                if not is_processing_done:
                    is_processing_done = _handle_double_col_layout(
                        presentation=presentation,
                        slide_json=a_slide,
                        slide_width_inch=slide_width_inch,
                        slide_height_inch=slide_height_inch
                    )

                if not is_processing_done:
                    is_processing_done = _handle_step_by_step_process(
                        presentation=presentation,
                        slide_json=a_slide,
                        slide_width_inch=slide_width_inch,
                        slide_height_inch=slide_height_inch
                    )

                if not is_processing_done:
                    _handle_default_display(
                        presentation=presentation,
                        slide_json=a_slide,
                        slide_width_inch=slide_width_inch,
                        slide_height_inch=slide_height_inch
                    )

        except Exception as e: # Catch specific exception
            logger.error(f"Error processing slide: {a_slide.get('heading', 'N/A')}", exc_info=True)
            # In case of any unforeseen error, try to salvage what is available
            continue

    # The thank-you slide
    last_slide_layout = presentation.slide_layouts[0]
    slide = presentation.slides.add_slide(last_slide_layout)
    title = slide.shapes.title
    title.text = 'Thank you!'

    presentation.save(output_file_path)

    return all_headers


def get_flat_list_of_contents(items: list, level: int) -> List[Tuple]:
    """
    Flatten a (hierarchical) list of bullet points to a single list containing each item and
    its level.

    :param items: A bullet point (string or list).
    :param level: The current level of hierarchy.
    :return: A list of (bullet item text, hierarchical level) tuples.
    """

    flat_list = []

    for item in items:
        if isinstance(item, str):
            flat_list.append((item, level))
        elif isinstance(item, list):
            flat_list = flat_list + get_flat_list_of_contents(item, level + 1)

    return flat_list


def get_slide_placeholders(
        slide: pptx.slide.Slide,
        layout_number: int,
        is_debug: bool = False
) -> List[Tuple[int, str]]:
    """
    Return the index and name (lower case) of all placeholders present in a slide, except
    the title placeholder.

    A placeholder in a slide is a place to add content. Each placeholder has a name and an index.
    This index is NOT a list index, rather a set of keys used to look up a dict. So, `idx` is
    non-contiguous. Also, the title placeholder of a slide always has index 0. User-added
    placeholder get indices assigned starting from 10.

    With user-edited or added placeholders, their index may be difficult to track. This function
    returns the placeholders name as well, which could be useful to distinguish between the
    different placeholder.

    :param slide: The slide.
    :param layout_number: The layout number used by the slide.
    :param is_debug: Whether to print debugging statements.
    :return: A list containing placeholders (idx, name) tuples, except the title placeholder.
    """

    if is_debug:
        print(
            f'Slide layout #{layout_number}:'
            f' # of placeholders: {len(slide.shapes.placeholders)} (including the title)'
        )

    placeholders = [
        (shape.placeholder_format.idx, shape.name.lower()) for shape in slide.shapes.placeholders
    ]
    # ตรวจสอบว่ามี placeholder อยู่ก่อน pop
    if len(placeholders) > 0 and placeholders[0][0] == 0: # ตรวจสอบว่า index 0 คือ title placeholder
        placeholders.pop(0)  # Remove the title placeholder

    if is_debug:
        print(placeholders)

    return placeholders


def _handle_default_display(
        presentation: pptx.Presentation,
        slide_json: dict,
        slide_width_inch: float,
        slide_height_inch: float
):
    """
    Display a list of text in a slide.

    :param presentation: The presentation object.
    :param slide_json: The content of the slide as JSON data.
    :param slide_width_inch: The width of the slide in inches.
    :param slide_height_inch: The height of the slide in inches.
    """

    status = False

    if 'img_keywords' in slide_json:
        if random.random() < IMAGE_DISPLAY_PROBABILITY:
            if random.random() < FOREGROUND_IMAGE_PROBABILITY:
                # ต้องแน่ใจว่าได้ import helpers.image_search as ims
                # หากยังไม่มี ต้อง import หรือ comment บรรทัดนี้
                # status = _handle_display_image__in_foreground(
                #     presentation,
                #     slide_json,
                #     slide_width_inch,
                #     slide_height_inch
                # )
                pass # placeholder if ims is not available
            else:
                # status = _handle_display_image__in_background(
                #     presentation,
                #     slide_json,
                #     slide_width_inch,
                #     slide_height_inch
                # )
                pass # placeholder if ims is not available

    if status:
        return

    # Image display failed, so display only text
    bullet_slide_layout = presentation.slide_layouts[1]
    slide = presentation.slides.add_slide(bullet_slide_layout)

    shapes = slide.shapes
    title_shape = shapes.title

    try:
        body_shape = shapes.placeholders[1]
    except KeyError:
        placeholders = get_slide_placeholders(slide, layout_number=1)
        body_shape = shapes.placeholders[placeholders[0][0]]

    title_shape.text = remove_slide_number_from_heading(slide_json['heading'])
    text_frame = body_shape.text_frame

    # The bullet_points may contain a nested hierarchy of JSON arrays
    # In some scenarios, it may contain objects (dictionaries) because the LLM generated so
    #  ^ The second scenario is not covered

    flat_items_list = get_flat_list_of_contents(slide_json['bullet_points'], level=0)

    for idx, an_item in enumerate(flat_items_list):
        if idx == 0:
            text_frame.text = an_item[0].removeprefix(STEP_BY_STEP_PROCESS_MARKER)
        else:
            paragraph = text_frame.add_paragraph()
            paragraph.text = an_item[0].removeprefix(STEP_BY_STEP_PROCESS_MARKER)
            paragraph.level = an_item[1]

    _handle_key_message(
        the_slide=slide,
        slide_json=slide_json,
        slide_height_inch=slide_height_inch,
        slide_width_inch=slide_width_inch
    )


# ฟังก์ชัน _handle_display_image__in_foreground และ _handle_display_image__in_background
# ต้องการ helpers.image_search หากคุณไม่ได้ใช้หรือไม่ต้องการฟังก์ชันนี้ คุณสามารถ comment ทิ้งได้
# หรือเพิ่ม implementation ของ ims.get_photo_url_from_api_response และ ims.get_image_from_url

def _handle_display_image__in_foreground(
        presentation: pptx.Presentation,
        slide_json: dict,
        slide_width_inch: float,
        slide_height_inch: float
) -> bool:
    """
    Create a slide with text and image using a picture placeholder layout. If not image keyword is
    available, it will add only text to the slide.

    :param presentation: The presentation object.
    :param slide_json: The content of the slide as JSON data.
    :param slide_width_inch: The width of the slide in inches.
    :param slide_height_inch: The height of the slide in inches.
    :return: True if the side has been processed.
    """
    if not hasattr(sys.modules['__main__'], 'ims'): # ตรวจสอบว่า ims ถูกโหลดหรือไม่
        logger.warning("helpers.image_search (ims) not imported. Skipping image foreground display.")
        return False

    img_keywords = slide_json['img_keywords'].strip()
    slide_layout_index = 8 # Picture with Caption layout
    
    # ตรวจสอบว่า layout index 8 มีอยู่หรือไม่
    if slide_layout_index >= len(presentation.slide_layouts):
        logger.error(f"Slide layout index {slide_layout_index} not found in the template.")
        return False

    slide = presentation.slide_layouts[slide_layout_index]
    slide = presentation.slides.add_slide(slide)
    placeholders = None

    title_placeholder = slide.shapes.title
    title_placeholder.text = remove_slide_number_from_heading(slide_json['heading'])

    pic_col: Optional[PicturePlaceholder] = None
    text_col: Optional[SlidePlaceholder] = None

    # ค้นหา placeholders ด้วยชื่อหรือ index
    # ใน template มาตรฐาน Picture with Caption (layout 8) มักจะมี placeholders ดังนี้:
    # Title (idx 0), Picture (idx 1), Content (idx 2)
    try:
        pic_col = slide.shapes.placeholders[1] # Picture Placeholder
        text_col = slide.shapes.placeholders[2] # Content Placeholder (for caption text)
    except KeyError:
        # Fallback if standard indices don't work (e.g., custom layouts)
        placeholders = get_slide_placeholders(slide, layout_number=slide_layout_index)
        for idx, name in placeholders:
            if 'picture placeholder' in name or 'picture' in name:
                pic_col = slide.shapes.placeholders[idx]
            if 'content placeholder' in name or 'text placeholder' in name:
                text_col = slide.shapes.placeholders[idx]

    if not pic_col or not text_col:
        logger.error("Could not find required picture or text placeholders in layout 8.")
        return False

    flat_items_list = get_flat_list_of_contents(slide_json['bullet_points'], level=0)

    for idx, an_item in enumerate(flat_items_list):
        if idx == 0:
            text_col.text_frame.text = an_item[0].removeprefix(STEP_BY_STEP_PROCESS_MARKER)
        else:
            paragraph = text_col.text_frame.add_paragraph()
            paragraph.text = an_item[0].removeprefix(STEP_BY_STEP_PROCESS_MARKER)
            paragraph.level = an_item[1]

    if not img_keywords:
        # No keywords, so no image search and addition
        return True

    try:
        # ต้องแน่ใจว่า ims.search_pexels และ ims.get_image_from_url ถูก implement หรือ mock ไว้
        photo_url, page_url = ims.get_photo_url_from_api_response(
            ims.search_pexels(query=img_keywords, size='medium')
        )

        if photo_url:
            pic_col.insert_picture(
                ims.get_image_from_url(photo_url)
            )

            _add_text_at_bottom(
                slide=slide,
                slide_width_inch=slide_width_inch,
                slide_height_inch=slide_height_inch,
                text='Photo provided by Pexels',
                hyperlink=page_url
            )
    except Exception as ex:
        logger.error(
            '*** Error occurred while running adding image to slide: %s',
            str(ex)
        )
        return False # Return False if image addition fails

    return True


def _handle_display_image__in_background(
        presentation: pptx.Presentation,
        slide_json: dict,
        slide_width_inch: float,
        slide_height_inch: float
) -> bool:
    """
    Add a slide with text and an image in the background. It works just like
    `_handle_default_display()` but with a background image added. If not image keyword is
    available, it will add only text to the slide.

    :param presentation: The presentation object.
    :param slide_json: The content of the slide as JSON data.
    :param slide_width_inch: The width of the slide in inches.
    :param slide_height_inch: The height of the slide in inches.
    :return: True if the slide has been processed.
    """
    if not hasattr(sys.modules['__main__'], 'ims'): # ตรวจสอบว่า ims ถูกโหลดหรือไม่
        logger.warning("helpers.image_search (ims) not imported. Skipping image background display.")
        return False

    img_keywords = slide_json['img_keywords'].strip()

    # Add a photo in the background, text in the foreground
    slide = presentation.slides.add_slide(presentation.slide_layouts[1]) # Title and Content layout
    title_shape = slide.shapes.title

    try:
        body_shape = slide.shapes.placeholders[1]
    except KeyError:
        placeholders = get_slide_placeholders(slide, layout_number=1)
        # Layout 1 usually has two placeholders, including the title
        body_shape = slide.shapes.placeholders[placeholders[0][0]]

    title_shape.text = remove_slide_number_from_heading(slide_json['heading'])

    flat_items_list = get_flat_list_of_contents(slide_json['bullet_points'], level=0)

    for idx, an_item in enumerate(flat_items_list):
        if idx == 0:
            body_shape.text_frame.text = an_item[0].removeprefix(STEP_BY_STEP_PROCESS_MARKER)
        else:
            paragraph = body_shape.text_frame.add_paragraph()
            paragraph.text = an_item[0].removeprefix(STEP_BY_STEP_PROCESS_MARKER)
            paragraph.level = an_item[1]

    if not img_keywords:
        # No keywords, so no image search and addition
        return True

    try:
        photo_url, page_url = ims.get_photo_url_from_api_response(
            ims.search_pexels(query=img_keywords, size='large')
        )

        if photo_url:
            picture = slide.shapes.add_picture(
                image_file=ims.get_image_from_url(photo_url),
                left=0,
                top=0,
                width=pptx.util.Inches(slide_width_inch),
            )

            _add_text_at_bottom(
                slide=slide,
                slide_width_inch=slide_width_inch,
                slide_height_inch=slide_height_inch,
                text='Photo provided by Pexels',
                hyperlink=page_url
            )

            # Move picture to background
            # https://github.com/scanny/python-pptx/issues/49#issuecomment-137172836
            slide.shapes._spTree.remove(picture._element)
            slide.shapes._spTree.insert(2, picture._element)
    except Exception as ex:
        logger.error(
            '*** Error occurred while running adding image to the slide background: %s',
            str(ex)
        )
        return False # Return False if image addition fails

    return True


def _handle_icons_ideas(
        presentation: pptx.Presentation,
        slide_json: dict,
        slide_width_inch: float,
        slide_height_inch: float
):
    """
    Add a slide with some icons and text.
    If no suitable icons are found, the step numbers are shown.

    :param presentation: The presentation object.
    :param slide_json: The content of the slide as JSON data.
    :param slide_width_inch: The width of the slide in inches.
    :param slide_height_inch: The height of the slide in inches.
    :return: True if the slide has been processed.
    """

    if not hasattr(sys.modules['__main__'], 'ice'): # ตรวจสอบว่า ice ถูกโหลดหรือไม่
        logger.warning("helpers.icons_embeddings (ice) not imported. Skipping icon display.")
        return False

    if 'bullet_points' in slide_json and slide_json['bullet_points']:
        items = slide_json['bullet_points']

        # Ensure that it is a single list of strings without any sub-list
        for step in items:
            if not isinstance(step, str) or not step.startswith(ICON_BEGINNING_MARKER):
                return False

        slide_layout_index = 5 # Title and two content layout
        if slide_layout_index >= len(presentation.slide_layouts):
            logger.error(f"Slide layout index {slide_layout_index} not found in the template.")
            return False

        slide_layout = presentation.slide_layouts[slide_layout_index]
        slide = presentation.slides.add_slide(slide_layout)
        slide.shapes.title.text = remove_slide_number_from_heading(slide_json['heading'])

        n_items = len(items)
        text_box_size = INCHES_2

        # Calculate the total width of all pictures and the spacing
        total_width = n_items * ICON_SIZE
        spacing = (pptx.util.Inches(slide_width_inch) - total_width) / (n_items + 1)
        top = INCHES_3

        icons_texts = [
            (match.group(1), match.group(2)) for match in [
                ICONS_REGEX.search(item) for item in items
            ] if match # เพิ่ม if match เพื่อกรอง None ออก
        ]
        
        # ตรวจสอบว่ามี icon_texts หรือไม่ก่อนที่จะเรียก find_icons
        if not icons_texts:
            logger.warning("No icon texts found for icon ideas slide.")
            return False

        fallback_icon_files = ice.find_icons([item[0] for item in icons_texts])

        for idx, item in enumerate(icons_texts):
            icon, accompanying_text = item
            icon_path = f'{GlobalConfig.ICONS_DIR}/{icon}.png'

            if not os.path.exists(icon_path):
                logger.warning(
                    'Icon not found: %s...using fallback icon: %s',
                    icon, fallback_icon_files[idx]
                )
                icon_path = f'{GlobalConfig.ICONS_DIR}/{fallback_icon_files[idx]}.png'

            left = spacing + idx * (ICON_SIZE + spacing)
            # Calculate the center position for alignment
            center = left + ICON_SIZE / 2

            # Add a rectangle shape with a fill color (background)
            # The size of the shape is slightly bigger than the icon, so align the icon position
            shape = slide.shapes.add_shape(
                MSO_AUTO_SHAPE_TYPE.ROUNDED_RECTANGLE,
                center - INCHES_0_5,
                top - (ICON_BG_SIZE - ICON_SIZE) / 2,
                INCHES_1, INCHES_1
            )
            shape.fill.solid()
            shape.shadow.inherit = False

            # Set the icon's background shape color
            shape.fill.fore_color.rgb = shape.line.color.rgb = random.choice(ICON_COLORS)

            # Add the icon image on top of the colored shape
            slide.shapes.add_picture(icon_path, left, top, height=ICON_SIZE)

            # Add a text box below the shape
            text_box = slide.shapes.add_shape(
                MSO_AUTO_SHAPE_TYPE.ROUNDED_RECTANGLE,
                left=center - text_box_size / 2,  # Center the text box horizontally
                top=top + ICON_SIZE + INCHES_0_2,
                width=text_box_size,
                height=text_box_size
            )
            text_frame = text_box.text_frame
            text_frame.text = accompanying_text
            text_frame.word_wrap = True
            text_frame.paragraphs[0].alignment = pptx.enum.text.PP_ALIGN.CENTER

            # Center the text vertically
            text_frame.vertical_anchor = pptx.enum.text.MSO_ANCHOR.MIDDLE
            text_box.fill.background()  # No fill
            text_box.line.fill.background()  # No line
            text_box.shadow.inherit = False

            # Set the font color based on the theme
            for paragraph in text_frame.paragraphs:
                for run in paragraph.runs:
                    run.font.color.theme_color = pptx.enum.dml.MSO_THEME_COLOR.TEXT_2

        # _add_text_at_bottom ควรถูกเรียกครั้งเดียวต่อสไลด์ ไม่ใช่ใน loop
        _add_text_at_bottom(
            slide=slide,
            slide_width_inch=slide_width_inch,
            slide_height_inch=slide_height_inch,
            text='More icons available in the SlideDeck AI repository',
            hyperlink='https://github.com/barun-saha/slide-deck-ai/tree/main/icons/png128'
        )

        return True

    return False


def _add_text_at_bottom(
        slide: pptx.slide.Slide,
        slide_width_inch: float,
        slide_height_inch: float,
        text: str,
        hyperlink: Optional[str] = None,
        target_height: Optional[float] = 0.5
):
    """
    Add arbitrary text to a textbox positioned near the lower left side of a slide.

    :param slide: The slide.
    :param slide_width_inch: The width of the slide.
    :param slide_height_inch: The height of the slide.
    :param target_height: the target height of the box in inches (optional).
    :param text: The text to be added
    :param hyperlink: The hyperlink to be added to the text (optional).
    """

    footer = slide.shapes.add_textbox(
        left=INCHES_1,
        top=pptx.util.Inches(slide_height_inch - target_height),
        width=pptx.util.Inches(slide_width_inch),
        height=pptx.util.Inches(target_height)
    )

    paragraph = footer.text_frame.paragraphs[0]
    run = paragraph.add_run()
    run.text = text
    run.font.size = pptx.util.Pt(10)
    run.font.underline = False

    if hyperlink:
        run.hyperlink.address = hyperlink


def _handle_double_col_layout(
        presentation: pptx.Presentation,
        slide_json: dict,
        slide_width_inch: float,
        slide_height_inch: float
) -> bool:
    """
    Add a slide with a double column layout for comparison.

    :param presentation: The presentation object.
    :param slide_json: The content of the slide as JSON data.
    :param slide_width_inch: The width of the slide in inches.
    :param slide_height_inch: The height of the slide in inches.
    :return: True if double col layout has been added; False otherwise.
    """

    if 'bullet_points' in slide_json and slide_json['bullet_points']:
        double_col_content = slide_json['bullet_points']

        if double_col_content and (
                len(double_col_content) == 2
        ) and isinstance(double_col_content[0], dict) and isinstance(double_col_content[1], dict):
            slide_layout_index = 4 # Two Content layout
            if slide_layout_index >= len(presentation.slide_layouts):
                logger.error(f"Slide layout index {slide_layout_index} not found in the template.")
                return False

            slide = presentation.slide_layouts[slide_layout_index]
            slide = presentation.slides.add_slide(slide)
            placeholders = None

            shapes = slide.shapes
            title_placeholder = shapes.title
            title_placeholder.text = remove_slide_number_from_heading(slide_json['heading'])

            left_heading, right_heading = None, None
            left_col, right_col = None, None

            # Attempt to get placeholders by standard indices first
            try:
                # Based on default PPTX layouts, placeholder indices for layout 4
                # Title: 0, Left Content: 1, Right Content: 2
                # Left Heading: 10 (or custom), Right Heading: 11 (or custom)
                # This depends heavily on your specific template.
                # It's safer to iterate and check names if not sure.
                # Assuming placeholders[1] and [2] are the main content bodies
                # and you might have separate heading placeholders for columns.
                
                # Check for standard content placeholders
                left_col = shapes.placeholders[1] 
                right_col = shapes.placeholders[2]

                # Check for specific heading placeholders if they exist by name or type
                # This part is highly dependent on your template. You might not have separate "headings" within the columns
                # but rather the first bullet point serves as a heading.
                # For a default "Two Content" layout, the placeholders are usually Title, Content Placeholder 1, Content Placeholder 2.
                # If your template has specific text placeholders for column headings, you need to identify them.
                # Example for custom named placeholders:
                for ph in shapes.placeholders:
                    if "left heading" in ph.name.lower():
                        left_heading = ph
                    if "right heading" in ph.name.lower():
                        right_heading = ph
            except KeyError:
                # Fallback to iterating through all placeholders if direct access fails
                placeholders = get_slide_placeholders(slide, layout_number=slide_layout_index)
                for idx, name in placeholders:
                    if 'content placeholder' in name:
                        if not left_col:
                            left_col = shapes.placeholders[idx]
                        elif not right_col:
                            right_col = shapes.placeholders[idx]
                    elif 'text placeholder' in name and ('heading' in name or 'title' in name):
                         if not left_heading:
                             left_heading = shapes.placeholders[idx]
                         elif not right_heading:
                             right_heading = shapes.placeholders[idx]

            if not left_col or not right_col:
                logger.error("Could not find left or right content placeholders in layout 4.")
                return False

            left_col_frame, right_col_frame = left_col.text_frame, right_col.text_frame

            # Process left column content
            if 'heading' in double_col_content[0] and left_heading:
                left_heading.text = double_col_content[0]['heading']
            elif 'heading' in double_col_content[0]: # If no specific heading placeholder, put in first bullet
                left_col_frame.text = double_col_content[0]['heading']
                
            if 'bullet_points' in double_col_content[0]:
                flat_items_list = get_flat_list_of_contents(
                    double_col_content[0]['bullet_points'], level=0
                )

                # If first item is also a heading, skip it if already set
                start_idx = 0
                if left_heading and 'heading' in double_col_content[0]:
                    pass # Heading already set
                elif not left_heading and 'heading' in double_col_content[0]:
                    # First item already set as heading in text_frame, start from next
                    if len(flat_items_list) > 0 and flat_items_list[0][0] == double_col_content[0]['heading']:
                        start_idx = 1
                
                for idx, an_item in enumerate(flat_items_list[start_idx:]):
                    if idx + start_idx == 0 and not left_heading: # Only set text_frame.text for the very first item if no separate heading
                        left_col_frame.text = an_item[0].removeprefix(STEP_BY_STEP_PROCESS_MARKER)
                    else:
                        paragraph = left_col_frame.add_paragraph()
                        paragraph.text = an_item[0].removeprefix(STEP_BY_STEP_PROCESS_MARKER)
                        paragraph.level = an_item[1]

            # Process right column content
            if 'heading' in double_col_content[1] and right_heading:
                right_heading.text = double_col_content[1]['heading']
            elif 'heading' in double_col_content[1]: # If no specific heading placeholder, put in first bullet
                right_col_frame.text = double_col_content[1]['heading']

            if 'bullet_points' in double_col_content[1]:
                flat_items_list = get_flat_list_of_contents(
                    double_col_content[1]['bullet_points'], level=0
                )
                
                start_idx = 0
                if right_heading and 'heading' in double_col_content[1]:
                    pass # Heading already set
                elif not right_heading and 'heading' in double_col_content[1]:
                    # First item already set as heading in text_frame, start from next
                    if len(flat_items_list) > 0 and flat_items_list[0][0] == double_col_content[1]['heading']:
                        start_idx = 1

                for idx, an_item in enumerate(flat_items_list[start_idx:]):
                    if idx + start_idx == 0 and not right_heading: # Only set text_frame.text for the very first item if no separate heading
                        right_col_frame.text = an_item[0].removeprefix(STEP_BY_STEP_PROCESS_MARKER)
                    else:
                        paragraph = right_col_frame.add_paragraph()
                        paragraph.text = an_item[0].removeprefix(STEP_BY_STEP_PROCESS_MARKER)
                        paragraph.level = an_item[1]

            _handle_key_message(
                the_slide=slide,
                slide_json=slide_json,
                slide_height_inch=slide_height_inch,
                slide_width_inch=slide_width_inch
            )

            return True

    return False


def _handle_step_by_step_process(
        presentation: pptx.Presentation,
        slide_json: dict,
        slide_width_inch: float,
        slide_height_inch: float
) -> bool:
    """
    Add shapes to display a step-by-step process in the slide, if available.

    :param presentation: The presentation object.
    :param slide_json: The content of the slide as JSON data.
    :param slide_width_inch: The width of the slide in inches.
    :param slide_height_inch: The height of the slide in inches.
    :return True if this slide has a step-by-step process depiction added; False otherwise.
    """

    if 'bullet_points' in slide_json and slide_json['bullet_points']:
        steps = slide_json['bullet_points']

        no_marker_count = 0.0
        n_steps = len(steps)

        # Ensure that it is a single list of strings without any sub-list
        for step in steps:
            if not isinstance(step, str):
                return False

            # In some cases, one or two steps may not begin with >>, e.g.:
            # {
            #     "heading": "Step-by-Step Process: Creating a Legacy",
            #     "bullet_points": [
            #         "Identify your unique talents and passions",
            #         ">> Develop your skills and knowledge",
            #         ">> Create meaningful work",
            #         ">> Share your work with the world",
            #         ">> Continuously learn and adapt"
            #     ],
            #     "key_message": ""
            # },
            #
            # Use a threshold, e.g., at most 20%
            if not step.startswith(STEP_BY_STEP_PROCESS_MARKER):
                no_marker_count += 1

        slide_header = slide_json['heading'].lower()
        if (no_marker_count / n_steps > 0.25) and not (
                ('step-by-step' in slide_header) or ('step by step' in slide_header)
        ):
            return False

        if n_steps < 3 or n_steps > 6:
            # Two steps -- probably not a process
            # More than 5--6 steps -- would likely cause a visual clutter
            return False

        bullet_slide_layout = presentation.slide_layouts[1]
        slide = presentation.slides.add_slide(bullet_slide_layout)
        shapes = slide.shapes
        shapes.title.text = remove_slide_number_from_heading(slide_json['heading'])

        if 3 <= n_steps <= 4:
            # Horizontal display
            height = INCHES_1_5
            width = pptx.util.Inches(slide_width_inch / n_steps - 0.01)
            top = pptx.util.Inches(slide_height_inch / 2)
            left = pptx.util.Inches((slide_width_inch - width.inches * n_steps) / 2 + 0.05)

            for step in steps:
                shape = shapes.add_shape(MSO_AUTO_SHAPE_TYPE.CHEVRON, left, top, width, height)
                shape.text = step.removeprefix(STEP_BY_STEP_PROCESS_MARKER)
                left += width - INCHES_0_4
        elif 4 < n_steps <= 6:
            # Vertical display
            height = pptx.util.Inches(0.65)
            top = pptx.util.Inches(slide_height_inch / 4)
            left = INCHES_1  # slide_width_inch - width.inches)

            # Find the close to median width, based on the length of each text, to be set
            # for the shapes
            width = pptx.util.Inches(slide_width_inch * 2 / 3)
            lengths = [len(step) for step in steps]
            font_size_20pt = pptx.util.Pt(20)
            widths = sorted(
                [
                    min(
                        pptx.util.Inches(font_size_20pt.inches * a_len),
                        width
                    ) for a_len in lengths
                ]
            )
            width = widths[len(widths) // 2]

            for step in steps:
                shape = shapes.add_shape(MSO_AUTO_SHAPE_TYPE.PENTAGON, left, top, width, height)
                shape.text = step.removeprefix(STEP_BY_STEP_PROCESS_MARKER)
                top += height + INCHES_0_3
                left += INCHES_0_5

    return True


def _handle_key_message(
        the_slide: pptx.slide.Slide,
        slide_json: dict,
        slide_width_inch: float,
        slide_height_inch: float
):
    """
    Add a shape to display the key message in the slide, if available.

    :param the_slide: The slide to be processed.
    :param slide_json: The content of the slide as JSON data.
    :param slide_width_inch: The width of the slide in inches.
    :param slide_height_inch: The height of the slide in inches.
    """

    if 'key_message' in slide_json and slide_json['key_message']:
        height = pptx.util.Inches(1.6)
        width = pptx.util.Inches(slide_width_inch / 2.3)
        top = pptx.util.Inches(slide_height_inch - height.inches - 0.1)
        left = pptx.util.Inches((slide_width_inch - width.inches) / 2)
        shape = the_slide.shapes.add_shape(
            MSO_AUTO_SHAPE_TYPE.ROUNDED_RECTANGLE,
            left=left,
            top=top,
            width=width,
            height=height
        )
        shape.text = slide_json['key_message']


def _get_slide_width_height_inches(presentation: pptx.Presentation) -> Tuple[float, float]:
    """
    Get the dimensions of a slide in inches.

    :param presentation: The presentation object.
    :return: The width and the height.
    """

    slide_width_inch = EMU_TO_INCH_SCALING_FACTOR * presentation.slide_width
    slide_height_inch = EMU_TO_INCH_SCALING_FACTOR * presentation.slide_height
    # logger.debug('Slide width: %f, height: %f', slide_width_inch, slide_height_inch)

    return slide_width_inch, slide_height_inch


def _handle_8d_report_table(
    presentation: pptx.Presentation,
    slide_json: dict,
    slide_width_inch: float,
    slide_height_inch: float
) -> bool:
    """
    Creates a slide and fills data into a specific table on that slide.
    This function assumes a pre-designed slide layout in the template
    that contains the 8D report table.

    :param presentation: The presentation object.
    :param slide_json: Dictionary containing data for the 8D report table.
                       Expected keys: 'heading', 'table_data'
                       'table_data' is a dictionary where keys map to cell positions.
    :param slide_width_inch: The width of the slide in inches.
    :param slide_height_inch: The height of the slide in inches.
    :return: True if the table was successfully filled, False otherwise.
    """
    # 1. ระบุ Slide Layout ที่มีตาราง 8D Report
    # คุณจะต้องรู้ว่า layout index ของ slide layout ที่มีตาราง 8D อยู่คืออะไร
    # หรือชื่อของ layout นั้น เช่น 'Title and Table' หรือ 'Custom Table Layout'
    # ในตัวอย่างนี้ ผมจะสมมติว่าคุณมี layout ที่เหมาะสมอยู่แล้ว และจะลองใช้ layout 1 (Title and Content)
    # แล้วค่อยหา table ในนั้น ถ้าคุณมี layout เฉพาะที่สร้างมาเพื่อตารางนี้โดยเฉพาะ
    # ควรใช้ layout index หรือชื่อที่ถูกต้องของมัน
    # เช่น: 8D_TABLE_LAYOUT_INDEX = 6 (สมมติ)
    
    # หากคุณต้องการสร้างสไลด์ใหม่สำหรับตาราง 8D
    # ลองหา layout ที่มีตารางอยู่แล้วใน template หรือสร้าง layout ใหม่ที่มี table
    
    # ตัวอย่าง: ใช้ layout ที่ 5 (Title and Content - แต่ไม่แน่ใจว่าจะมี Table Placeholder ไหม)
    # ถ้าไม่มี layout ที่มี table placeholder ใน template คุณอาจจะต้องสร้าง table ด้วยโค้ด
    # หรือใช้ template ที่มีตารางเปล่าอยู่แล้ว
    
    # วิธีที่ 1: ใช้ slide layout ที่มีอยู่แล้วและหวังว่าจะมี table
    # หาก template ของคุณมี layout สำหรับตาราง 8D โดยเฉพาะ
    # ให้เปลี่ยน `presentation.slide_layouts[X]` เป็น layout ที่ถูกต้อง
    
    # ลองใช้ layout ที่เหมาะสมที่สุดใน template ที่มีอยู่ หรือ สร้าง layout ใหม่ใน template
    # สำหรับตัวอย่างนี้ ผมจะสมมติว่ามี layout ที่ 5 (Title and Two Content)
    # และเราจะสร้างตารางเข้าไป หรือหาตารางที่มีอยู่แล้ว
    
    # เพื่อความแม่นยำที่สุด คุณควรเปิดไฟล์ .pptx template ของคุณใน PowerPoint
    # แล้วไปที่ "Slide Master View" เพื่อดู Layouts และชื่อของ Shapes/Placeholders
    # หรือใช้โค้ด Python เพื่อลิสต์ placeholders/shapes ในแต่ละ layout เพื่อระบุตำแหน่งของตาราง
    
    # วิธีการที่ปลอดภัยกว่า: เพิ่มสไลด์เปล่า แล้วสร้างตารางขึ้นมาเอง (ถ้า template ไม่มีตารางสำเร็จรูป)
    # แต่จากภาพที่คุณให้มา ดูเหมือนจะเป็นตารางที่จัดวางไว้ล่วงหน้าแล้ว
    
    # ลองหา layout ที่น่าจะมีตาราง หรือสร้างสไลด์เปล่าแล้วเพิ่มตาราง (ถ้าไม่มี layout เฉพาะ)
    # สำหรับตัวอย่างนี้ ผมจะสมมติว่ามี layout สำหรับตาราง 8D ที่ index 1 (Title and Content)
    # และจะไปหา Table Shape ในนั้น
    
    # --- สำคัญ: ตรงนี้คือส่วนที่คุณต้องปรับเปลี่ยนให้เข้ากับ template ของคุณ ---
    # เช่น ถ้าคุณรู้ว่า layout ที่ 6 คือ layout สำหรับ 8D report table
    report_table_layout_index = 1 # เปลี่ยนเป็น index ที่ถูกต้องใน template ของคุณ
                                 # หาก template ของคุณมี layout สำหรับตาราง 8D โดยเฉพาะ
                                 # ลองไล่ดู presentation.slide_layouts เพื่อหา index ที่เหมาะสม

    if report_table_layout_index >= len(presentation.slide_layouts):
        logger.error(f"8D Report Table Layout (index {report_table_layout_index}) not found in the template.")
        return False

    slide_layout = presentation.slide_layouts[report_table_layout_index]
    slide = presentation.slides.add_slide(slide_layout)
    
    # ตั้งค่าหัวข้อสไลด์
    slide.shapes.title.text = remove_slide_number_from_heading(slide_json.get('heading', '8D Report Details'))

    # ค้นหาตารางในสไลด์
    # ตารางอาจจะเป็น Shape หรือ Placeholder ก็ได้
    table = None
    for shape in slide.shapes:
        if shape.has_table:
            table = shape.table
            logger.info("Found a table in the slide.")
            break
    
    if table is None:
        logger.warning("No existing table found in the selected slide layout. Attempting to add a new table.")
        # หากไม่มีตารางใน layout, เราจะสร้างตารางใหม่
        # คุณจะต้องกำหนดจำนวนแถวและคอลัมน์ให้ตรงกับภาพที่คุณให้มา
        # และตำแหน่งของตารางในสไลด์
        # จากภาพ: มีประมาณ 7 แถว (ไม่รวมหัวตาราง) x 4 คอลัมน์
        rows, cols = 7, 4 # ปรับตามจำนวนแถวและคอลัมน์จริงในภาพของคุณ
        left_pos = Inches(1)
        top_pos = Inches(2)
        width = Inches(slide_width_inch - 2) # เกือบเต็มความกว้างสไลด์
        height = Inches(slide_height_inch - 3) # เกือบเต็มความสูงสไลด์
        
        try:
            table_shape = slide.shapes.add_table(rows, cols, left_pos, top_pos, width, height)
            table = table_shape.table
            logger.info("Successfully added a new table to the slide.")
        except Exception as e:
            logger.error(f"Failed to add a new table: {e}")
            return False

    # ตรวจสอบว่ามีข้อมูลตารางส่งมาหรือไม่
    table_data = slide_json.get('table_data')
    if not table_data:
        logger.warning("No 'table_data' found in slide_json for 8D report table.")
        # อาจจะแค่สร้างสไลด์เปล่าที่มีตารางเปล่า
        return True # ถือว่าสำเร็จในการสร้างสไลด์และตาราง (แต่ไม่มีข้อมูลเติม)

    # Dictionary สำหรับ mapping key จาก Streamlit inputs ไปยัง cell (row, col)
    # นี่คือส่วนที่สำคัญที่สุด คุณต้องจับคู่ข้อความที่ไฮไลท์ด้วยสีเหลือง
    # ในภาพของคุณ กับตำแหน่ง cell ที่ถูกต้อง (row, col)
    # เริ่มต้น index ของแถวและคอลัมน์จาก 0
    # ตัวอย่างการ mapping (คุณต้องปรับแก้ตาม layout ตารางจริงของคุณ)
    cell_mapping = {
        "title": (0, 1), # แถว 0, คอลัมน์ 1 (สมมติว่าเป็นช่องสำหรับ Title)
        "utl_ecar_no": (1, 1),
        "utl_lot_no": (2, 1),
        "customer_lot_no": (3, 1),
        "wafer_lot_no": (4, 1),
        "lot_size": (5, 1),
        "process_detected": (6, 1), # อาจจะอยู่แถว 6, คอลัมน์ 1
        
        "customer_car_no": (1, 3), # แถว 1, คอลัมน์ 3
        "acknowledged_date": (2, 3),
        "3d_date": (3, 3),
        "problem_verification_date": (4, 3),
        "4d_date": (5, 3),
        "8d_date": (6, 3),
    }

    # เติมข้อมูลลงในตาราง
    for key, (row, col) in cell_mapping.items():
        value = str(table_data.get(key, "")) # ดึงข้อมูลจาก table_data, ใช้ค่าว่างถ้าไม่มี
        
        # ตรวจสอบขอบเขตของตาราง
        if row < table.rows.__len__() and col < table.columns.__len__():
            cell = table.cell(row, col)
            text_frame = cell.text_frame
            text_frame.clear() # ล้างข้อความเก่า (ถ้ามี)
            p = text_frame.paragraphs[0]
            run = p.add_run()
            run.text = value
            
            # ปรับแต่งฟอนต์ (optional)
            font = run.font
            font.name = 'Arial' # ตัวอย่าง
            font.size = pptx.util.Pt(11) # ตัวอย่าง
            # font.bold = True if key == "title" else False # ตัวอย่าง
            
            # จัด alignment (optional)
            p.alignment = pptx.enum.text.PP_ALIGN.LEFT # หรือ CENTER, RIGHT

        else:
            logger.warning(f"Cell ({row}, {col}) for key '{key}' is out of table bounds. Value: '{value}'")
    
    # เพิ่ม "CLASS 3 DOCUMENT" ที่ด้านล่าง
    _add_text_at_bottom(
        slide=slide,
        slide_width_inch=slide_width_inch,
        slide_height_inch=slide_height_inch,
        text='CLASS 3 DOCUMENT'
    )

    return True

# ฟังก์ชันอื่นๆ ที่คุณมีอยู่แล้ว

# ... (โค้ดส่วนล่างของคุณ)

if __name__ == '__main__':
    # กำหนด GlobalConfig ชั่วคราวสำหรับการทดสอบ
    class MockGlobalConfig:
        PPTX_TEMPLATE_FILES = {
            'default': {'file': 'your_8D_report_template.pptx'} # ตรวจสอบชื่อไฟล์ template
        }
        ICONS_DIR = './icons' # ถ้ามี icons directory
    
    GlobalConfig = MockGlobalConfig() # ใช้ Mock แทน GlobalConfig จริง

    # สร้างไฟล์ template เปล่าชั่วคราวสำหรับการทดสอบ ถ้ายังไม่มี
    template_file = GlobalConfig.PPTX_TEMPLATE_FILES['default']['file']
    if not os.path.exists(template_file):
        print(f"Template file '{template_file}' not found. Creating a dummy one for testing.")
        prs = pptx.Presentation()
        # เพิ่ม layout เปล่าที่มี table (ถ้าต้องการทดสอบ _handle_8d_report_table แบบสร้างใหม่)
        # หรือเพิ่ม layout ที่มีตาราง placeholder ไว้
        # ในที่นี้จะสร้าง template เปล่าๆ เพื่อให้ generate_powerpoint_presentation ทำงานได้
        prs.save(template_file)
        print("Dummy template created. Please customize it with your 8D table layout.")

    # สร้าง folder icons ถ้ายังไม่มี
    if not os.path.exists(GlobalConfig.ICONS_DIR):
        os.makedirs(GlobalConfig.ICONS_DIR)


    _JSON_DATA = '''
    {
      "title": "Global 8D Report - Example",
      "slides": [
        {
          "heading": "8D Report Details",
          "type": "8d_report_table",
          "table_data": {
            "title": "8D-UTL 2024-001 (Internal)",
            "utl_ecar_no": "UTL-ECAR-2024-001",
            "utl_lot_no": "UTL-LOT-XYZ789",
            "customer_lot_no": "CUST-LOT-ABC123",
            "wafer_lot_no": "WF-LOT-DEF456",
            "lot_size": "1000 pcs",
            "process_detected": "Final Test",
            "customer_car_no": "CAR-CUST-987",
            "acknowledged_date": "2024-07-30",
            "3d_date": "2024-08-01 : Rev 1 ; Date: 2024-08-01",
            "problem_verification_date": "2024-07-28 (Sample received)",
            "4d_date": "2024-08-05 : Rev 1 ; Date: 2024-08-05",
            "8d_date": "2024-08-15 : Rev 1 ; Date: 2024-08-15"
          }
        },
        {
          "heading": "Introduction to AI Applications",
          "bullet_points": [
            "Artificial Intelligence (AI) is transforming various industries",
            "AI applications range from simple decision-making tools to complex systems",
            "AI can be categorized into types: Rule-based, Instance-based, and Model-based"
          ],
          "key_message": "AI is a powerful tool for innovation."
        },
        {
          "heading": "Key Steps in Project Management",
          "bullet_points": [
            ">> Planning and Scope Definition",
            ">> Resource Allocation",
            ">> Execution and Monitoring",
            ">> Risk Management",
            ">> Quality Assurance",
            ">> Project Closure"
          ]
        },
        {
            "heading": "Icons Example",
            "bullet_points": [
                "[[bulb]] Innovative Ideas",
                "[[gear]] Operational Efficiency",
                "[[chart]] Data Analysis"
            ]
        }
      ]
    }
    '''
    # โหลดข้อมูล JSON ที่สมบูรณ์
    parsed_json_data = json5.loads(_JSON_DATA)
    output_path = pathlib.Path("./generated_report.pptx")
    print(f"Generating presentation to {output_path}")
    headers = generate_powerpoint_presentation(
        parsed_data=parsed_json_data,
        slides_template='default',
        output_file_path=output_path
    )
    print(f"Generated with headers: {headers}")
